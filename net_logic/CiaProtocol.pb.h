// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CiaProtocol.proto

#ifndef PROTOBUF_CiaProtocol_2eproto__INCLUDED
#define PROTOBUF_CiaProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CiaProtocol_2eproto();
void protobuf_AssignDesc_CiaProtocol_2eproto();
void protobuf_ShutdownFile_CiaProtocol_2eproto();

class ciaMessage;

// ===================================================================

class ciaMessage : public ::google::protobuf::Message {
 public:
  ciaMessage();
  virtual ~ciaMessage();

  ciaMessage(const ciaMessage& from);

  inline ciaMessage& operator=(const ciaMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ciaMessage& default_instance();

  void Swap(ciaMessage* other);

  // implements Message ----------------------------------------------

  ciaMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ciaMessage& from);
  void MergeFrom(const ciaMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string signalId = 2;
  inline bool has_signalid() const;
  inline void clear_signalid();
  static const int kSignalIdFieldNumber = 2;
  inline const ::std::string& signalid() const;
  inline void set_signalid(const ::std::string& value);
  inline void set_signalid(const char* value);
  inline void set_signalid(const char* value, size_t size);
  inline ::std::string* mutable_signalid();
  inline ::std::string* release_signalid();
  inline void set_allocated_signalid(::std::string* signalid);

  // optional string status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // optional string pn = 4;
  inline bool has_pn() const;
  inline void clear_pn();
  static const int kPnFieldNumber = 4;
  inline const ::std::string& pn() const;
  inline void set_pn(const ::std::string& value);
  inline void set_pn(const char* value);
  inline void set_pn(const char* value, size_t size);
  inline ::std::string* mutable_pn();
  inline ::std::string* release_pn();
  inline void set_allocated_pn(::std::string* pn);

  // optional string appId = 5;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 5;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string authKey = 6;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 6;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // optional string imsi = 7;
  inline bool has_imsi() const;
  inline void clear_imsi();
  static const int kImsiFieldNumber = 7;
  inline const ::std::string& imsi() const;
  inline void set_imsi(const ::std::string& value);
  inline void set_imsi(const char* value);
  inline void set_imsi(const char* value, size_t size);
  inline ::std::string* mutable_imsi();
  inline ::std::string* release_imsi();
  inline void set_allocated_imsi(::std::string* imsi);

  // optional string transId = 8;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransIdFieldNumber = 8;
  inline const ::std::string& transid() const;
  inline void set_transid(const ::std::string& value);
  inline void set_transid(const char* value);
  inline void set_transid(const char* value, size_t size);
  inline ::std::string* mutable_transid();
  inline ::std::string* release_transid();
  inline void set_allocated_transid(::std::string* transid);

  // optional string authCode = 9;
  inline bool has_authcode() const;
  inline void clear_authcode();
  static const int kAuthCodeFieldNumber = 9;
  inline const ::std::string& authcode() const;
  inline void set_authcode(const ::std::string& value);
  inline void set_authcode(const char* value);
  inline void set_authcode(const char* value, size_t size);
  inline ::std::string* mutable_authcode();
  inline ::std::string* release_authcode();
  inline void set_allocated_authcode(::std::string* authcode);

  // optional string timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline const ::std::string& timeout() const;
  inline void set_timeout(const ::std::string& value);
  inline void set_timeout(const char* value);
  inline void set_timeout(const char* value, size_t size);
  inline ::std::string* mutable_timeout();
  inline ::std::string* release_timeout();
  inline void set_allocated_timeout(::std::string* timeout);

  // optional string des = 11;
  inline bool has_des() const;
  inline void clear_des();
  static const int kDesFieldNumber = 11;
  inline const ::std::string& des() const;
  inline void set_des(const ::std::string& value);
  inline void set_des(const char* value);
  inline void set_des(const char* value, size_t size);
  inline ::std::string* mutable_des();
  inline ::std::string* release_des();
  inline void set_allocated_des(::std::string* des);

  // optional string imei = 12;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 12;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string mac = 13;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 13;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string bluetooth = 14;
  inline bool has_bluetooth() const;
  inline void clear_bluetooth();
  static const int kBluetoothFieldNumber = 14;
  inline const ::std::string& bluetooth() const;
  inline void set_bluetooth(const ::std::string& value);
  inline void set_bluetooth(const char* value);
  inline void set_bluetooth(const char* value, size_t size);
  inline ::std::string* mutable_bluetooth();
  inline ::std::string* release_bluetooth();
  inline void set_allocated_bluetooth(::std::string* bluetooth);

  // optional string androidId = 15;
  inline bool has_androidid() const;
  inline void clear_androidid();
  static const int kAndroidIdFieldNumber = 15;
  inline const ::std::string& androidid() const;
  inline void set_androidid(const ::std::string& value);
  inline void set_androidid(const char* value);
  inline void set_androidid(const char* value, size_t size);
  inline ::std::string* mutable_androidid();
  inline ::std::string* release_androidid();
  inline void set_allocated_androidid(::std::string* androidid);

  // optional string brand = 16;
  inline bool has_brand() const;
  inline void clear_brand();
  static const int kBrandFieldNumber = 16;
  inline const ::std::string& brand() const;
  inline void set_brand(const ::std::string& value);
  inline void set_brand(const char* value);
  inline void set_brand(const char* value, size_t size);
  inline ::std::string* mutable_brand();
  inline ::std::string* release_brand();
  inline void set_allocated_brand(::std::string* brand);

  // optional string phoneType = 17;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 17;
  inline const ::std::string& phonetype() const;
  inline void set_phonetype(const ::std::string& value);
  inline void set_phonetype(const char* value);
  inline void set_phonetype(const char* value, size_t size);
  inline ::std::string* mutable_phonetype();
  inline ::std::string* release_phonetype();
  inline void set_allocated_phonetype(::std::string* phonetype);

  // optional string systemVersion = 18;
  inline bool has_systemversion() const;
  inline void clear_systemversion();
  static const int kSystemVersionFieldNumber = 18;
  inline const ::std::string& systemversion() const;
  inline void set_systemversion(const ::std::string& value);
  inline void set_systemversion(const char* value);
  inline void set_systemversion(const char* value, size_t size);
  inline ::std::string* mutable_systemversion();
  inline ::std::string* release_systemversion();
  inline void set_allocated_systemversion(::std::string* systemversion);

  // optional string appName = 19;
  inline bool has_appname() const;
  inline void clear_appname();
  static const int kAppNameFieldNumber = 19;
  inline const ::std::string& appname() const;
  inline void set_appname(const ::std::string& value);
  inline void set_appname(const char* value);
  inline void set_appname(const char* value, size_t size);
  inline ::std::string* mutable_appname();
  inline ::std::string* release_appname();
  inline void set_allocated_appname(::std::string* appname);

  // optional string appVersion = 20;
  inline bool has_appversion() const;
  inline void clear_appversion();
  static const int kAppVersionFieldNumber = 20;
  inline const ::std::string& appversion() const;
  inline void set_appversion(const ::std::string& value);
  inline void set_appversion(const char* value);
  inline void set_appversion(const char* value, size_t size);
  inline ::std::string* mutable_appversion();
  inline ::std::string* release_appversion();
  inline void set_allocated_appversion(::std::string* appversion);

  // optional string packageName = 21;
  inline bool has_packagename() const;
  inline void clear_packagename();
  static const int kPackageNameFieldNumber = 21;
  inline const ::std::string& packagename() const;
  inline void set_packagename(const ::std::string& value);
  inline void set_packagename(const char* value);
  inline void set_packagename(const char* value, size_t size);
  inline ::std::string* mutable_packagename();
  inline ::std::string* release_packagename();
  inline void set_allocated_packagename(::std::string* packagename);

  // optional string sdkVersion = 22;
  inline bool has_sdkversion() const;
  inline void clear_sdkversion();
  static const int kSdkVersionFieldNumber = 22;
  inline const ::std::string& sdkversion() const;
  inline void set_sdkversion(const ::std::string& value);
  inline void set_sdkversion(const char* value);
  inline void set_sdkversion(const char* value, size_t size);
  inline ::std::string* mutable_sdkversion();
  inline ::std::string* release_sdkversion();
  inline void set_allocated_sdkversion(::std::string* sdkversion);

  // @@protoc_insertion_point(class_scope:ciaMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_signalid();
  inline void clear_has_signalid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_pn();
  inline void clear_has_pn();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_authkey();
  inline void clear_has_authkey();
  inline void set_has_imsi();
  inline void clear_has_imsi();
  inline void set_has_transid();
  inline void clear_has_transid();
  inline void set_has_authcode();
  inline void clear_has_authcode();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_des();
  inline void clear_has_des();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_bluetooth();
  inline void clear_has_bluetooth();
  inline void set_has_androidid();
  inline void clear_has_androidid();
  inline void set_has_brand();
  inline void clear_has_brand();
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_systemversion();
  inline void clear_has_systemversion();
  inline void set_has_appname();
  inline void clear_has_appname();
  inline void set_has_appversion();
  inline void clear_has_appversion();
  inline void set_has_packagename();
  inline void clear_has_packagename();
  inline void set_has_sdkversion();
  inline void clear_has_sdkversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* signalid_;
  ::std::string* status_;
  ::std::string* pn_;
  ::std::string* appid_;
  ::std::string* authkey_;
  ::std::string* imsi_;
  ::std::string* transid_;
  ::std::string* authcode_;
  ::std::string* timeout_;
  ::std::string* des_;
  ::std::string* imei_;
  ::std::string* mac_;
  ::std::string* bluetooth_;
  ::std::string* androidid_;
  ::std::string* brand_;
  ::std::string* phonetype_;
  ::std::string* systemversion_;
  ::std::string* appname_;
  ::std::string* appversion_;
  ::std::string* packagename_;
  ::std::string* sdkversion_;
  friend void  protobuf_AddDesc_CiaProtocol_2eproto();
  friend void protobuf_AssignDesc_CiaProtocol_2eproto();
  friend void protobuf_ShutdownFile_CiaProtocol_2eproto();

  void InitAsDefaultInstance();
  static ciaMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ciaMessage

// required string type = 1;
inline bool ciaMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ciaMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ciaMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ciaMessage::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ciaMessage::type() const {
  // @@protoc_insertion_point(field_get:ciaMessage.type)
  return *type_;
}
inline void ciaMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.type)
}
inline void ciaMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.type)
}
inline void ciaMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.type)
}
inline ::std::string* ciaMessage::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.type)
  return type_;
}
inline ::std::string* ciaMessage::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.type)
}

// optional string signalId = 2;
inline bool ciaMessage::has_signalid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ciaMessage::set_has_signalid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ciaMessage::clear_has_signalid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ciaMessage::clear_signalid() {
  if (signalid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signalid_->clear();
  }
  clear_has_signalid();
}
inline const ::std::string& ciaMessage::signalid() const {
  // @@protoc_insertion_point(field_get:ciaMessage.signalId)
  return *signalid_;
}
inline void ciaMessage::set_signalid(const ::std::string& value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.signalId)
}
inline void ciaMessage::set_signalid(const char* value) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.signalId)
}
inline void ciaMessage::set_signalid(const char* value, size_t size) {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signalid_ = new ::std::string;
  }
  signalid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.signalId)
}
inline ::std::string* ciaMessage::mutable_signalid() {
  set_has_signalid();
  if (signalid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signalid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.signalId)
  return signalid_;
}
inline ::std::string* ciaMessage::release_signalid() {
  clear_has_signalid();
  if (signalid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signalid_;
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_signalid(::std::string* signalid) {
  if (signalid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signalid_;
  }
  if (signalid) {
    set_has_signalid();
    signalid_ = signalid;
  } else {
    clear_has_signalid();
    signalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.signalId)
}

// optional string status = 3;
inline bool ciaMessage::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ciaMessage::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ciaMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ciaMessage::clear_status() {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& ciaMessage::status() const {
  // @@protoc_insertion_point(field_get:ciaMessage.status)
  return *status_;
}
inline void ciaMessage::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.status)
}
inline void ciaMessage::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.status)
}
inline void ciaMessage::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.status)
}
inline ::std::string* ciaMessage::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.status)
  return status_;
}
inline ::std::string* ciaMessage::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.status)
}

// optional string pn = 4;
inline bool ciaMessage::has_pn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ciaMessage::set_has_pn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ciaMessage::clear_has_pn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ciaMessage::clear_pn() {
  if (pn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pn_->clear();
  }
  clear_has_pn();
}
inline const ::std::string& ciaMessage::pn() const {
  // @@protoc_insertion_point(field_get:ciaMessage.pn)
  return *pn_;
}
inline void ciaMessage::set_pn(const ::std::string& value) {
  set_has_pn();
  if (pn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pn_ = new ::std::string;
  }
  pn_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.pn)
}
inline void ciaMessage::set_pn(const char* value) {
  set_has_pn();
  if (pn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pn_ = new ::std::string;
  }
  pn_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.pn)
}
inline void ciaMessage::set_pn(const char* value, size_t size) {
  set_has_pn();
  if (pn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pn_ = new ::std::string;
  }
  pn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.pn)
}
inline ::std::string* ciaMessage::mutable_pn() {
  set_has_pn();
  if (pn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.pn)
  return pn_;
}
inline ::std::string* ciaMessage::release_pn() {
  clear_has_pn();
  if (pn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pn_;
    pn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_pn(::std::string* pn) {
  if (pn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pn_;
  }
  if (pn) {
    set_has_pn();
    pn_ = pn;
  } else {
    clear_has_pn();
    pn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.pn)
}

// optional string appId = 5;
inline bool ciaMessage::has_appid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ciaMessage::set_has_appid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ciaMessage::clear_has_appid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ciaMessage::clear_appid() {
  if (appid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& ciaMessage::appid() const {
  // @@protoc_insertion_point(field_get:ciaMessage.appId)
  return *appid_;
}
inline void ciaMessage::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.appId)
}
inline void ciaMessage::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.appId)
}
inline void ciaMessage::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.appId)
}
inline ::std::string* ciaMessage::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.appId)
  return appid_;
}
inline ::std::string* ciaMessage::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.appId)
}

// optional string authKey = 6;
inline bool ciaMessage::has_authkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ciaMessage::set_has_authkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ciaMessage::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ciaMessage::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& ciaMessage::authkey() const {
  // @@protoc_insertion_point(field_get:ciaMessage.authKey)
  return *authkey_;
}
inline void ciaMessage::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.authKey)
}
inline void ciaMessage::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.authKey)
}
inline void ciaMessage::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.authKey)
}
inline ::std::string* ciaMessage::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.authKey)
  return authkey_;
}
inline ::std::string* ciaMessage::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.authKey)
}

// optional string imsi = 7;
inline bool ciaMessage::has_imsi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ciaMessage::set_has_imsi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ciaMessage::clear_has_imsi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ciaMessage::clear_imsi() {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_->clear();
  }
  clear_has_imsi();
}
inline const ::std::string& ciaMessage::imsi() const {
  // @@protoc_insertion_point(field_get:ciaMessage.imsi)
  return *imsi_;
}
inline void ciaMessage::set_imsi(const ::std::string& value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.imsi)
}
inline void ciaMessage::set_imsi(const char* value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.imsi)
}
inline void ciaMessage::set_imsi(const char* value, size_t size) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.imsi)
}
inline ::std::string* ciaMessage::mutable_imsi() {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.imsi)
  return imsi_;
}
inline ::std::string* ciaMessage::release_imsi() {
  clear_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imsi_;
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_imsi(::std::string* imsi) {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imsi) {
    set_has_imsi();
    imsi_ = imsi;
  } else {
    clear_has_imsi();
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.imsi)
}

// optional string transId = 8;
inline bool ciaMessage::has_transid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ciaMessage::set_has_transid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ciaMessage::clear_has_transid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ciaMessage::clear_transid() {
  if (transid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transid_->clear();
  }
  clear_has_transid();
}
inline const ::std::string& ciaMessage::transid() const {
  // @@protoc_insertion_point(field_get:ciaMessage.transId)
  return *transid_;
}
inline void ciaMessage::set_transid(const ::std::string& value) {
  set_has_transid();
  if (transid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transid_ = new ::std::string;
  }
  transid_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.transId)
}
inline void ciaMessage::set_transid(const char* value) {
  set_has_transid();
  if (transid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transid_ = new ::std::string;
  }
  transid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.transId)
}
inline void ciaMessage::set_transid(const char* value, size_t size) {
  set_has_transid();
  if (transid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transid_ = new ::std::string;
  }
  transid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.transId)
}
inline ::std::string* ciaMessage::mutable_transid() {
  set_has_transid();
  if (transid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.transId)
  return transid_;
}
inline ::std::string* ciaMessage::release_transid() {
  clear_has_transid();
  if (transid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transid_;
    transid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_transid(::std::string* transid) {
  if (transid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transid_;
  }
  if (transid) {
    set_has_transid();
    transid_ = transid;
  } else {
    clear_has_transid();
    transid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.transId)
}

// optional string authCode = 9;
inline bool ciaMessage::has_authcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ciaMessage::set_has_authcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ciaMessage::clear_has_authcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ciaMessage::clear_authcode() {
  if (authcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authcode_->clear();
  }
  clear_has_authcode();
}
inline const ::std::string& ciaMessage::authcode() const {
  // @@protoc_insertion_point(field_get:ciaMessage.authCode)
  return *authcode_;
}
inline void ciaMessage::set_authcode(const ::std::string& value) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.authCode)
}
inline void ciaMessage::set_authcode(const char* value) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.authCode)
}
inline void ciaMessage::set_authcode(const char* value, size_t size) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.authCode)
}
inline ::std::string* ciaMessage::mutable_authcode() {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.authCode)
  return authcode_;
}
inline ::std::string* ciaMessage::release_authcode() {
  clear_has_authcode();
  if (authcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authcode_;
    authcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_authcode(::std::string* authcode) {
  if (authcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authcode_;
  }
  if (authcode) {
    set_has_authcode();
    authcode_ = authcode;
  } else {
    clear_has_authcode();
    authcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.authCode)
}

// optional string timeout = 10;
inline bool ciaMessage::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ciaMessage::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ciaMessage::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ciaMessage::clear_timeout() {
  if (timeout_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeout_->clear();
  }
  clear_has_timeout();
}
inline const ::std::string& ciaMessage::timeout() const {
  // @@protoc_insertion_point(field_get:ciaMessage.timeout)
  return *timeout_;
}
inline void ciaMessage::set_timeout(const ::std::string& value) {
  set_has_timeout();
  if (timeout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeout_ = new ::std::string;
  }
  timeout_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.timeout)
}
inline void ciaMessage::set_timeout(const char* value) {
  set_has_timeout();
  if (timeout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeout_ = new ::std::string;
  }
  timeout_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.timeout)
}
inline void ciaMessage::set_timeout(const char* value, size_t size) {
  set_has_timeout();
  if (timeout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeout_ = new ::std::string;
  }
  timeout_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.timeout)
}
inline ::std::string* ciaMessage::mutable_timeout() {
  set_has_timeout();
  if (timeout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeout_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.timeout)
  return timeout_;
}
inline ::std::string* ciaMessage::release_timeout() {
  clear_has_timeout();
  if (timeout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = timeout_;
    timeout_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_timeout(::std::string* timeout) {
  if (timeout_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timeout_;
  }
  if (timeout) {
    set_has_timeout();
    timeout_ = timeout;
  } else {
    clear_has_timeout();
    timeout_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.timeout)
}

// optional string des = 11;
inline bool ciaMessage::has_des() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ciaMessage::set_has_des() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ciaMessage::clear_has_des() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ciaMessage::clear_des() {
  if (des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_->clear();
  }
  clear_has_des();
}
inline const ::std::string& ciaMessage::des() const {
  // @@protoc_insertion_point(field_get:ciaMessage.des)
  return *des_;
}
inline void ciaMessage::set_des(const ::std::string& value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.des)
}
inline void ciaMessage::set_des(const char* value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.des)
}
inline void ciaMessage::set_des(const char* value, size_t size) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.des)
}
inline ::std::string* ciaMessage::mutable_des() {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.des)
  return des_;
}
inline ::std::string* ciaMessage::release_des() {
  clear_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = des_;
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_des(::std::string* des) {
  if (des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete des_;
  }
  if (des) {
    set_has_des();
    des_ = des;
  } else {
    clear_has_des();
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.des)
}

// optional string imei = 12;
inline bool ciaMessage::has_imei() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ciaMessage::set_has_imei() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ciaMessage::clear_has_imei() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ciaMessage::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ciaMessage::imei() const {
  // @@protoc_insertion_point(field_get:ciaMessage.imei)
  return *imei_;
}
inline void ciaMessage::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.imei)
}
inline void ciaMessage::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.imei)
}
inline void ciaMessage::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.imei)
}
inline ::std::string* ciaMessage::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.imei)
  return imei_;
}
inline ::std::string* ciaMessage::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.imei)
}

// optional string mac = 13;
inline bool ciaMessage::has_mac() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ciaMessage::set_has_mac() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ciaMessage::clear_has_mac() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ciaMessage::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& ciaMessage::mac() const {
  // @@protoc_insertion_point(field_get:ciaMessage.mac)
  return *mac_;
}
inline void ciaMessage::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.mac)
}
inline void ciaMessage::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.mac)
}
inline void ciaMessage::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.mac)
}
inline ::std::string* ciaMessage::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.mac)
  return mac_;
}
inline ::std::string* ciaMessage::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.mac)
}

// optional string bluetooth = 14;
inline bool ciaMessage::has_bluetooth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ciaMessage::set_has_bluetooth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ciaMessage::clear_has_bluetooth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ciaMessage::clear_bluetooth() {
  if (bluetooth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetooth_->clear();
  }
  clear_has_bluetooth();
}
inline const ::std::string& ciaMessage::bluetooth() const {
  // @@protoc_insertion_point(field_get:ciaMessage.bluetooth)
  return *bluetooth_;
}
inline void ciaMessage::set_bluetooth(const ::std::string& value) {
  set_has_bluetooth();
  if (bluetooth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetooth_ = new ::std::string;
  }
  bluetooth_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.bluetooth)
}
inline void ciaMessage::set_bluetooth(const char* value) {
  set_has_bluetooth();
  if (bluetooth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetooth_ = new ::std::string;
  }
  bluetooth_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.bluetooth)
}
inline void ciaMessage::set_bluetooth(const char* value, size_t size) {
  set_has_bluetooth();
  if (bluetooth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetooth_ = new ::std::string;
  }
  bluetooth_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.bluetooth)
}
inline ::std::string* ciaMessage::mutable_bluetooth() {
  set_has_bluetooth();
  if (bluetooth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bluetooth_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.bluetooth)
  return bluetooth_;
}
inline ::std::string* ciaMessage::release_bluetooth() {
  clear_has_bluetooth();
  if (bluetooth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bluetooth_;
    bluetooth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_bluetooth(::std::string* bluetooth) {
  if (bluetooth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bluetooth_;
  }
  if (bluetooth) {
    set_has_bluetooth();
    bluetooth_ = bluetooth;
  } else {
    clear_has_bluetooth();
    bluetooth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.bluetooth)
}

// optional string androidId = 15;
inline bool ciaMessage::has_androidid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ciaMessage::set_has_androidid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ciaMessage::clear_has_androidid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ciaMessage::clear_androidid() {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_->clear();
  }
  clear_has_androidid();
}
inline const ::std::string& ciaMessage::androidid() const {
  // @@protoc_insertion_point(field_get:ciaMessage.androidId)
  return *androidid_;
}
inline void ciaMessage::set_androidid(const ::std::string& value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.androidId)
}
inline void ciaMessage::set_androidid(const char* value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.androidId)
}
inline void ciaMessage::set_androidid(const char* value, size_t size) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.androidId)
}
inline ::std::string* ciaMessage::mutable_androidid() {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.androidId)
  return androidid_;
}
inline ::std::string* ciaMessage::release_androidid() {
  clear_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = androidid_;
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_androidid(::std::string* androidid) {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete androidid_;
  }
  if (androidid) {
    set_has_androidid();
    androidid_ = androidid;
  } else {
    clear_has_androidid();
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.androidId)
}

// optional string brand = 16;
inline bool ciaMessage::has_brand() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ciaMessage::set_has_brand() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ciaMessage::clear_has_brand() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ciaMessage::clear_brand() {
  if (brand_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_->clear();
  }
  clear_has_brand();
}
inline const ::std::string& ciaMessage::brand() const {
  // @@protoc_insertion_point(field_get:ciaMessage.brand)
  return *brand_;
}
inline void ciaMessage::set_brand(const ::std::string& value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.brand)
}
inline void ciaMessage::set_brand(const char* value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.brand)
}
inline void ciaMessage::set_brand(const char* value, size_t size) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.brand)
}
inline ::std::string* ciaMessage::mutable_brand() {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.brand)
  return brand_;
}
inline ::std::string* ciaMessage::release_brand() {
  clear_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = brand_;
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_brand(::std::string* brand) {
  if (brand_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete brand_;
  }
  if (brand) {
    set_has_brand();
    brand_ = brand;
  } else {
    clear_has_brand();
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.brand)
}

// optional string phoneType = 17;
inline bool ciaMessage::has_phonetype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ciaMessage::set_has_phonetype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ciaMessage::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ciaMessage::clear_phonetype() {
  if (phonetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_->clear();
  }
  clear_has_phonetype();
}
inline const ::std::string& ciaMessage::phonetype() const {
  // @@protoc_insertion_point(field_get:ciaMessage.phoneType)
  return *phonetype_;
}
inline void ciaMessage::set_phonetype(const ::std::string& value) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.phoneType)
}
inline void ciaMessage::set_phonetype(const char* value) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.phoneType)
}
inline void ciaMessage::set_phonetype(const char* value, size_t size) {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  phonetype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.phoneType)
}
inline ::std::string* ciaMessage::mutable_phonetype() {
  set_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phonetype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.phoneType)
  return phonetype_;
}
inline ::std::string* ciaMessage::release_phonetype() {
  clear_has_phonetype();
  if (phonetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phonetype_;
    phonetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_phonetype(::std::string* phonetype) {
  if (phonetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phonetype_;
  }
  if (phonetype) {
    set_has_phonetype();
    phonetype_ = phonetype;
  } else {
    clear_has_phonetype();
    phonetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.phoneType)
}

// optional string systemVersion = 18;
inline bool ciaMessage::has_systemversion() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ciaMessage::set_has_systemversion() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ciaMessage::clear_has_systemversion() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ciaMessage::clear_systemversion() {
  if (systemversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemversion_->clear();
  }
  clear_has_systemversion();
}
inline const ::std::string& ciaMessage::systemversion() const {
  // @@protoc_insertion_point(field_get:ciaMessage.systemVersion)
  return *systemversion_;
}
inline void ciaMessage::set_systemversion(const ::std::string& value) {
  set_has_systemversion();
  if (systemversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemversion_ = new ::std::string;
  }
  systemversion_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.systemVersion)
}
inline void ciaMessage::set_systemversion(const char* value) {
  set_has_systemversion();
  if (systemversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemversion_ = new ::std::string;
  }
  systemversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.systemVersion)
}
inline void ciaMessage::set_systemversion(const char* value, size_t size) {
  set_has_systemversion();
  if (systemversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemversion_ = new ::std::string;
  }
  systemversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.systemVersion)
}
inline ::std::string* ciaMessage::mutable_systemversion() {
  set_has_systemversion();
  if (systemversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.systemVersion)
  return systemversion_;
}
inline ::std::string* ciaMessage::release_systemversion() {
  clear_has_systemversion();
  if (systemversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = systemversion_;
    systemversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_systemversion(::std::string* systemversion) {
  if (systemversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete systemversion_;
  }
  if (systemversion) {
    set_has_systemversion();
    systemversion_ = systemversion;
  } else {
    clear_has_systemversion();
    systemversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.systemVersion)
}

// optional string appName = 19;
inline bool ciaMessage::has_appname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ciaMessage::set_has_appname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ciaMessage::clear_has_appname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ciaMessage::clear_appname() {
  if (appname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appname_->clear();
  }
  clear_has_appname();
}
inline const ::std::string& ciaMessage::appname() const {
  // @@protoc_insertion_point(field_get:ciaMessage.appName)
  return *appname_;
}
inline void ciaMessage::set_appname(const ::std::string& value) {
  set_has_appname();
  if (appname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appname_ = new ::std::string;
  }
  appname_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.appName)
}
inline void ciaMessage::set_appname(const char* value) {
  set_has_appname();
  if (appname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appname_ = new ::std::string;
  }
  appname_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.appName)
}
inline void ciaMessage::set_appname(const char* value, size_t size) {
  set_has_appname();
  if (appname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appname_ = new ::std::string;
  }
  appname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.appName)
}
inline ::std::string* ciaMessage::mutable_appname() {
  set_has_appname();
  if (appname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.appName)
  return appname_;
}
inline ::std::string* ciaMessage::release_appname() {
  clear_has_appname();
  if (appname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = appname_;
    appname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_appname(::std::string* appname) {
  if (appname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete appname_;
  }
  if (appname) {
    set_has_appname();
    appname_ = appname;
  } else {
    clear_has_appname();
    appname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.appName)
}

// optional string appVersion = 20;
inline bool ciaMessage::has_appversion() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ciaMessage::set_has_appversion() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ciaMessage::clear_has_appversion() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ciaMessage::clear_appversion() {
  if (appversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appversion_->clear();
  }
  clear_has_appversion();
}
inline const ::std::string& ciaMessage::appversion() const {
  // @@protoc_insertion_point(field_get:ciaMessage.appVersion)
  return *appversion_;
}
inline void ciaMessage::set_appversion(const ::std::string& value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.appVersion)
}
inline void ciaMessage::set_appversion(const char* value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.appVersion)
}
inline void ciaMessage::set_appversion(const char* value, size_t size) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.appVersion)
}
inline ::std::string* ciaMessage::mutable_appversion() {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.appVersion)
  return appversion_;
}
inline ::std::string* ciaMessage::release_appversion() {
  clear_has_appversion();
  if (appversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = appversion_;
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_appversion(::std::string* appversion) {
  if (appversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete appversion_;
  }
  if (appversion) {
    set_has_appversion();
    appversion_ = appversion;
  } else {
    clear_has_appversion();
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.appVersion)
}

// optional string packageName = 21;
inline bool ciaMessage::has_packagename() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ciaMessage::set_has_packagename() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ciaMessage::clear_has_packagename() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ciaMessage::clear_packagename() {
  if (packagename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagename_->clear();
  }
  clear_has_packagename();
}
inline const ::std::string& ciaMessage::packagename() const {
  // @@protoc_insertion_point(field_get:ciaMessage.packageName)
  return *packagename_;
}
inline void ciaMessage::set_packagename(const ::std::string& value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.packageName)
}
inline void ciaMessage::set_packagename(const char* value) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.packageName)
}
inline void ciaMessage::set_packagename(const char* value, size_t size) {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagename_ = new ::std::string;
  }
  packagename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.packageName)
}
inline ::std::string* ciaMessage::mutable_packagename() {
  set_has_packagename();
  if (packagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packagename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.packageName)
  return packagename_;
}
inline ::std::string* ciaMessage::release_packagename() {
  clear_has_packagename();
  if (packagename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packagename_;
    packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_packagename(::std::string* packagename) {
  if (packagename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packagename_;
  }
  if (packagename) {
    set_has_packagename();
    packagename_ = packagename;
  } else {
    clear_has_packagename();
    packagename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.packageName)
}

// optional string sdkVersion = 22;
inline bool ciaMessage::has_sdkversion() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ciaMessage::set_has_sdkversion() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ciaMessage::clear_has_sdkversion() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ciaMessage::clear_sdkversion() {
  if (sdkversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sdkversion_->clear();
  }
  clear_has_sdkversion();
}
inline const ::std::string& ciaMessage::sdkversion() const {
  // @@protoc_insertion_point(field_get:ciaMessage.sdkVersion)
  return *sdkversion_;
}
inline void ciaMessage::set_sdkversion(const ::std::string& value) {
  set_has_sdkversion();
  if (sdkversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sdkversion_ = new ::std::string;
  }
  sdkversion_->assign(value);
  // @@protoc_insertion_point(field_set:ciaMessage.sdkVersion)
}
inline void ciaMessage::set_sdkversion(const char* value) {
  set_has_sdkversion();
  if (sdkversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sdkversion_ = new ::std::string;
  }
  sdkversion_->assign(value);
  // @@protoc_insertion_point(field_set_char:ciaMessage.sdkVersion)
}
inline void ciaMessage::set_sdkversion(const char* value, size_t size) {
  set_has_sdkversion();
  if (sdkversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sdkversion_ = new ::std::string;
  }
  sdkversion_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ciaMessage.sdkVersion)
}
inline ::std::string* ciaMessage::mutable_sdkversion() {
  set_has_sdkversion();
  if (sdkversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sdkversion_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ciaMessage.sdkVersion)
  return sdkversion_;
}
inline ::std::string* ciaMessage::release_sdkversion() {
  clear_has_sdkversion();
  if (sdkversion_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sdkversion_;
    sdkversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ciaMessage::set_allocated_sdkversion(::std::string* sdkversion) {
  if (sdkversion_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sdkversion_;
  }
  if (sdkversion) {
    set_has_sdkversion();
    sdkversion_ = sdkversion;
  } else {
    clear_has_sdkversion();
    sdkversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ciaMessage.sdkVersion)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CiaProtocol_2eproto__INCLUDED
